// Generated by uRequire v0.2.1
(function (root, factory) {
  if (typeof exports === 'object') {
    var nr = new (require('urequire').NodeRequirer) ('XCSSMatrix.js', __dirname, 'false');
    module.exports = factory(nr.require, exports, module);
  } else if (typeof define === 'function' && define.amd) {
      define( factory);
  }
}) (this, function (require, exports, module) {
  var isWeb = (typeof define === 'function' && define.amd);
  var isNode = !isWeb;
  // uRequire: start body of original node module
  var utils = {
    angles: require("./angleUtils"),
    matrix: require("./matrixUtils"),
    transp: require("./cssTransformStringUtils"),
    funcs: {
        onlyFirstArg: function(fn, context) {
            context = context || this;
            return function(first) {
                return fn.call(context, first);
            };
        }
    }
};

function XCSSMatrix(domstr) {
    this.m11 = this.m22 = this.m33 = this.m44 = 1;
    this.m12 = this.m13 = this.m14 = this.m21 = this.m23 = this.m24 = this.m31 = this.m32 = this.m34 = this.m41 = this.m42 = this.m43 = 0;
    if (typeof domstr === "string") {
        this.setMatrixValue(domstr);
    }
}

XCSSMatrix.displayName = "XCSSMatrix";

var points2d = [ "a", "b", "c", "d", "e", "f" ];

var points3d = [ "m11", "m12", "m13", "m14", "m21", "m22", "m23", "m24", "m31", "m32", "m33", "m34", "m41", "m42", "m43", "m44" ];

[ [ "m11", "a" ], [ "m12", "b" ], [ "m21", "c" ], [ "m22", "d" ], [ "m41", "e" ], [ "m42", "f" ] ].forEach(function(pair) {
    var key3d = pair[0], key2d = pair[1];
    Object.defineProperty(XCSSMatrix.prototype, key2d, {
        set: function(val) {
            this[key3d] = val;
        },
        get: function() {
            return this[key3d];
        },
        enumerable: true,
        configurable: true
    });
});

XCSSMatrix.prototype.multiply = function(otherMatrix) {
    if (!otherMatrix) return null;
    var a = otherMatrix, b = this, c = new XCSSMatrix;
    c.m11 = a.m11 * b.m11 + a.m12 * b.m21 + a.m13 * b.m31 + a.m14 * b.m41;
    c.m12 = a.m11 * b.m12 + a.m12 * b.m22 + a.m13 * b.m32 + a.m14 * b.m42;
    c.m13 = a.m11 * b.m13 + a.m12 * b.m23 + a.m13 * b.m33 + a.m14 * b.m43;
    c.m14 = a.m11 * b.m14 + a.m12 * b.m24 + a.m13 * b.m34 + a.m14 * b.m44;
    c.m21 = a.m21 * b.m11 + a.m22 * b.m21 + a.m23 * b.m31 + a.m24 * b.m41;
    c.m22 = a.m21 * b.m12 + a.m22 * b.m22 + a.m23 * b.m32 + a.m24 * b.m42;
    c.m23 = a.m21 * b.m13 + a.m22 * b.m23 + a.m23 * b.m33 + a.m24 * b.m43;
    c.m24 = a.m21 * b.m14 + a.m22 * b.m24 + a.m23 * b.m34 + a.m24 * b.m44;
    c.m31 = a.m31 * b.m11 + a.m32 * b.m21 + a.m33 * b.m31 + a.m34 * b.m41;
    c.m32 = a.m31 * b.m12 + a.m32 * b.m22 + a.m33 * b.m32 + a.m34 * b.m42;
    c.m33 = a.m31 * b.m13 + a.m32 * b.m23 + a.m33 * b.m33 + a.m34 * b.m43;
    c.m34 = a.m31 * b.m14 + a.m32 * b.m24 + a.m33 * b.m34 + a.m34 * b.m44;
    c.m41 = a.m41 * b.m11 + a.m42 * b.m21 + a.m43 * b.m31 + a.m44 * b.m41;
    c.m42 = a.m41 * b.m12 + a.m42 * b.m22 + a.m43 * b.m32 + a.m44 * b.m42;
    c.m43 = a.m41 * b.m13 + a.m42 * b.m23 + a.m43 * b.m33 + a.m44 * b.m43;
    c.m44 = a.m41 * b.m14 + a.m42 * b.m24 + a.m43 * b.m34 + a.m44 * b.m44;
    return c;
};

XCSSMatrix.prototype.inverse = function() {
    var inv;
    if (utils.matrix.isIdentityOrTranslation(this)) {
        inv = new XCSSMatrix;
        if (!(this.m41 === 0 && this.m42 === 0 && this.m43 === 0)) {
            inv.m41 = -this.m41;
            inv.m42 = -this.m42;
            inv.m43 = -this.m43;
        }
        return inv;
    }
    var result = utils.matrix.adjoint(this);
    var det = utils.matrix.determinant4x4(this);
    if (Math.abs(det) < 1e-8) return null;
    for (var i = 1; i < 5; i++) {
        for (var j = 1; j < 5; j++) {
            result["m" + i + j] /= det;
        }
    }
    return result;
};

XCSSMatrix.prototype.rotate = function(rx, ry, rz) {
    if (typeof rx !== "number" || isNaN(rx)) rx = 0;
    if ((typeof ry !== "number" || isNaN(ry)) && (typeof rz !== "number" || isNaN(rz))) {
        rz = rx;
        rx = 0;
        ry = 0;
    }
    if (typeof ry !== "number" || isNaN(ry)) ry = 0;
    if (typeof rz !== "number" || isNaN(rz)) rz = 0;
    rx = utils.angles.deg2rad(rx);
    ry = utils.angles.deg2rad(ry);
    rz = utils.angles.deg2rad(rz);
    var tx = new XCSSMatrix, ty = new XCSSMatrix, tz = new XCSSMatrix, sinA, cosA, sinA2;
    rz /= 2;
    sinA = Math.sin(rz);
    cosA = Math.cos(rz);
    sinA2 = sinA * sinA;
    tz.m11 = tz.m22 = 1 - 2 * sinA2;
    tz.m12 = tz.m21 = 2 * sinA * cosA;
    tz.m21 *= -1;
    ry /= 2;
    sinA = Math.sin(ry);
    cosA = Math.cos(ry);
    sinA2 = sinA * sinA;
    ty.m11 = ty.m33 = 1 - 2 * sinA2;
    ty.m13 = ty.m31 = 2 * sinA * cosA;
    ty.m13 *= -1;
    rx /= 2;
    sinA = Math.sin(rx);
    cosA = Math.cos(rx);
    sinA2 = sinA * sinA;
    tx.m22 = tx.m33 = 1 - 2 * sinA2;
    tx.m23 = tx.m32 = 2 * sinA * cosA;
    tx.m32 *= -1;
    var identityMatrix = new XCSSMatrix;
    var isIdentity = this.toString() === identityMatrix.toString();
    var rotatedMatrix = isIdentity ? tz.multiply(ty).multiply(tx) : this.multiply(tx).multiply(ty).multiply(tz);
    return rotatedMatrix;
};

XCSSMatrix.prototype.rotateAxisAngle = function(x, y, z, a) {
    if (typeof x !== "number" || isNaN(x)) x = 0;
    if (typeof y !== "number" || isNaN(y)) y = 0;
    if (typeof z !== "number" || isNaN(z)) z = 0;
    if (typeof a !== "number" || isNaN(a)) a = 0;
    if (x === 0 && y === 0 && z === 0) z = 1;
    var t = new XCSSMatrix, len = Math.sqrt(x * x + y * y + z * z), cosA, sinA, sinA2, csA, x2, y2, z2;
    a = (utils.angles.deg2rad(a) || 0) / 2;
    cosA = Math.cos(a);
    sinA = Math.sin(a);
    sinA2 = sinA * sinA;
    if (len === 0) {
        x = 0;
        y = 0;
        z = 1;
    } else if (len !== 1) {
        x /= len;
        y /= len;
        z /= len;
    }
    if (x === 1 && y === 0 && z === 0) {
        t.m22 = t.m33 = 1 - 2 * sinA2;
        t.m23 = t.m32 = 2 * cosA * sinA;
        t.m32 *= -1;
    } else if (x === 0 && y === 1 && z === 0) {
        t.m11 = t.m33 = 1 - 2 * sinA2;
        t.m13 = t.m31 = 2 * cosA * sinA;
        t.m13 *= -1;
    } else if (x === 0 && y === 0 && z === 1) {
        t.m11 = t.m22 = 1 - 2 * sinA2;
        t.m12 = t.m21 = 2 * cosA * sinA;
        t.m21 *= -1;
    } else {
        csA = sinA * cosA;
        x2 = x * x;
        y2 = y * y;
        z2 = z * z;
        t.m11 = 1 - 2 * (y2 + z2) * sinA2;
        t.m12 = 2 * (x * y * sinA2 + z * csA);
        t.m13 = 2 * (x * z * sinA2 - y * csA);
        t.m21 = 2 * (y * x * sinA2 - z * csA);
        t.m22 = 1 - 2 * (z2 + x2) * sinA2;
        t.m23 = 2 * (y * z * sinA2 + x * csA);
        t.m31 = 2 * (z * x * sinA2 + y * csA);
        t.m32 = 2 * (z * y * sinA2 - x * csA);
        t.m33 = 1 - 2 * (x2 + y2) * sinA2;
    }
    return this.multiply(t);
};

XCSSMatrix.prototype.scale = function(scaleX, scaleY, scaleZ) {
    var transform = new XCSSMatrix;
    if (typeof scaleX !== "number" || isNaN(scaleX)) scaleX = 1;
    if (typeof scaleY !== "number" || isNaN(scaleY)) scaleY = scaleX;
    if (typeof scaleZ !== "number" || isNaN(scaleZ)) scaleZ = 1;
    transform.m11 = scaleX;
    transform.m22 = scaleY;
    transform.m33 = scaleZ;
    return this.multiply(transform);
};

XCSSMatrix.prototype.skewX = function(degrees) {
    var radians = utils.angles.deg2rad(degrees);
    var transform = new XCSSMatrix;
    transform.c = Math.tan(radians);
    return this.multiply(transform);
};

XCSSMatrix.prototype.skewY = function(degrees) {
    var radians = utils.angles.deg2rad(degrees);
    var transform = new XCSSMatrix;
    transform.b = Math.tan(radians);
    return this.multiply(transform);
};

XCSSMatrix.prototype.translate = function(x, y, z) {
    var t = new XCSSMatrix;
    if (typeof x !== "number" || isNaN(x)) x = 0;
    if (typeof y !== "number" || isNaN(y)) y = 0;
    if (typeof z !== "number" || isNaN(z)) z = 0;
    t.m41 = x;
    t.m42 = y;
    t.m43 = z;
    return this.multiply(t);
};

XCSSMatrix.prototype.setMatrixValue = function(domstr) {
    var matrixString = toMatrixString(domstr.trim());
    var matrixObject = utils.transp.statementToObject(matrixString);
    if (!matrixObject) return;
    var is3d = matrixObject.key === utils.transp.matrixFn3d;
    var keygen = is3d ? indextoKey3d : indextoKey2d;
    var values = matrixObject.value;
    var count = values.length;
    if (is3d && count !== 16 || !(is3d || count === 6)) return;
    values.forEach(function(obj, i) {
        var key = keygen(i);
        this[key] = obj.value;
    }, this);
};

function indextoKey2d(index) {
    return String.fromCharCode(index + 97);
}

function indextoKey3d(index) {
    return "m" + (Math.floor(index / 4) + 1) + (index % 4 + 1);
}

XCSSMatrix.prototype.toString = function() {
    var points, prefix;
    if (utils.matrix.isAffine(this)) {
        prefix = utils.transp.matrixFn2d;
        points = points2d;
    } else {
        prefix = utils.transp.matrixFn3d;
        points = points3d;
    }
    return prefix + "(" + points.map(function(p) {
        return this[p].toFixed(6);
    }, this).join(", ") + ")";
};

var jsFunctions = {
    matrix: function(m, o) {
        var m2 = new XCSSMatrix(o.unparsed);
        return m.multiply(m2);
    },
    matrix3d: function(m, o) {
        var m2 = new XCSSMatrix(o.unparsed);
        return m.multiply(m2);
    },
    perspective: function(m, o) {
        var m2 = new XCSSMatrix;
        m2.m34 -= 1 / o.value[0].value;
        return m.multiply(m2);
    },
    rotate: function(m, o) {
        return m.rotate.apply(m, o.value.map(objectValues));
    },
    rotate3d: function(m, o) {
        return m.rotateAxisAngle.apply(m, o.value.map(objectValues));
    },
    rotateX: function(m, o) {
        return m.rotate.apply(m, [ o.value[0].value, 0, 0 ]);
    },
    rotateY: function(m, o) {
        return m.rotate.apply(m, [ 0, o.value[0].value, 0 ]);
    },
    rotateZ: function(m, o) {
        return m.rotate.apply(m, [ 0, 0, o.value[0].value ]);
    },
    scale: function(m, o) {
        return m.scale.apply(m, o.value.map(objectValues));
    },
    scale3d: function(m, o) {
        return m.scale.apply(m, o.value.map(objectValues));
    },
    scaleX: function(m, o) {
        return m.scale.apply(m, o.value.map(objectValues));
    },
    scaleY: function(m, o) {
        return m.scale.apply(m, [ 0, o.value[0].value, 0 ]);
    },
    scaleZ: function(m, o) {
        return m.scale.apply(m, [ 0, 0, o.value[0].value ]);
    },
    skew: function(m, o) {
        var mX = new XCSSMatrix("skewX(" + o.value[0].unparsed + ")");
        var mY = new XCSSMatrix("skewY(" + (o.value[1] && o.value[1].unparsed || 0) + ")");
        var sM = "matrix(1.00000, " + mY.b + ", " + mX.c + ", 1.000000, 0.000000, 0.000000)";
        var m2 = new XCSSMatrix(sM);
        return m.multiply(m2);
    },
    skewX: function(m, o) {
        return m.skewX.apply(m, [ o.value[0].value ]);
    },
    skewY: function(m, o) {
        return m.skewY.apply(m, [ o.value[0].value ]);
    },
    translate: function(m, o) {
        return m.translate.apply(m, o.value.map(objectValues));
    },
    translate3d: function(m, o) {
        return m.translate.apply(m, o.value.map(objectValues));
    },
    translateX: function(m, o) {
        return m.translate.apply(m, [ o.value[0].value, 0, 0 ]);
    },
    translateY: function(m, o) {
        return m.translate.apply(m, [ 0, o.value[0].value, 0 ]);
    },
    translateZ: function(m, o) {
        return m.translate.apply(m, [ 0, 0, o.value[0].value ]);
    }
};

function objectValues(obj) {
    return obj.value;
}

function cssFunctionToJsFunction(cssFunctionName) {
    return jsFunctions[cssFunctionName];
}

function parsedToDegrees(parsed) {
    if (parsed.units === "rad") {
        parsed.value = utils.angles.rad2deg(parsed.value);
        parsed.units = "deg";
    } else if (parsed.units === "grad") {
        parsed.value = utils.angles.grad2deg(parsed.value);
        parsed.units = "deg";
    }
    return parsed;
}

function transformMatrix(matrix, operation) {
    operation.value = operation.value.map(parsedToDegrees);
    var jsFunction = cssFunctionToJsFunction(operation.key);
    var result = jsFunction(matrix, operation);
    return result || matrix;
}

function toMatrixString(transformString) {
    var statements = utils.transp.stringToStatements(transformString);
    if (statements.length === 1 && /^matrix/.test(transformString)) {
        return transformString;
    }
    var statementToObject = utils.funcs.onlyFirstArg(utils.transp.statementToObject);
    var operations = statements.map(statementToObject);
    var startingMatrix = new XCSSMatrix;
    var transformedMatrix = operations.reduce(transformMatrix, startingMatrix);
    var matrixString = transformedMatrix.toString();
    return matrixString;
}

module.exports = XCSSMatrix;
  // uRequire: end body of original node module 
return module.exports;
});